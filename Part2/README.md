**TASK 1**

Дана непустая строка s, длина которой N не превышает 10^6. Будем считать, что элементы строки нумеруются от 1 до N.

Для каждой позиции i символа в строке определим Z-блок как наибольшую подстроку, которая начинается в этой позиции и совпадает с некоторым началом всей строки s. Значением Z-функции Z(i) будем считать длину этого Z-блока. (Заметим, что для первой позиции строки Z-блок совпадает со всей строкой, поэтому Z(1) = N. С другой стороны, если s[i] ≠ s[1], то Z(i) = 0).

Z-функция используется в различных алгоритмах обработки строк. В частности, с её помощью можно быстро решать задачу о поиске вхождения одной строки в другую («поиск по образцу»).

Требуется для всех i от 1 до N вычислить Z(i).

**TASK 2**

Вася любит наблюдать за звездами. Но следить за всем небом сразу ему тяжело. Поэтому он наблюдает только за частью пространства, ограниченной кубом размером n на n на n. Этот куб поделён на маленькие кубики размером 1x1x1. Во время его наблюдений могут происходить следующие события:

• в каком-то кубике появляются или исчезают несколько звезд;
• к нему может заглянуть его друг Петя и поинтересоваться, сколько видно звезд в части пространства, состоящей из нескольких кубиков.

Input format
Первая строка входного файла содержит натуральное число n (n ≤ 128). Координаты кубиков - целые число от 0 до n-1. Далее следуют записи о происходивших событиях по одной в строке.

В начале строки записано число m. Если m равно:

• 1, то за ним следуют 4 числа: x, y, z, k. (0 ≤ x, y, z < N, -20000 ≤ k ≤ 20000) - координаты кубика и величина, на которую в нем изменилось количество видимых звезд;
• 2, то за ним следуют 6 чисел: x1, y1, z1, x2, y2, z2 (0 ≤ xi, yi, zi < N, x1 ≤ x2, y1 ≤ y2, z1 ≤ z2 которые означают, что Петя попросил подсчитать количество звезд в кубиках (x', y', z') из области: x1 ≤ x' ≤ x2, y1 ≤ y' ≤ y2, z1 ≤ z' ≤ z2.
• 3, то это означает, что Васе надоело наблюдать за звездами и отвечать на вопросы Пети. Эта запись встречается во входном файле только один раз и будет последней записью. Количество записей во входном файле не превосходит 100500.

* Output format
Для каждого Петиного вопроса выведите на отдельной строке одно число - искомое количество звезд.

**TASK 3**

Дан массив из n чисел. Требуется написать программу, которая будет отвечать на запросы следующего вида: найти минимум на отрезке между u и v включительно.

**TASK 4**

Реализуйте структуру данных для эффективного вычисления НОД нескольких подряд идущих элементов массива.

* Input format
В первой строке вводится одно натуральное число N(1 ≤ N ≤ 105) - количество чисел в массиве.

Во второй строке вводятся N чисел от 1 до 100000 - элементы массива.

В третьей строке вводится одно натуральное число K(1 ≤ K ≤ 30000) - количество запросов на вычисление НОД.

В следующих K строках вводится по два числа - номера левого и правого элементов отрезка массива (считается, что элементы массива нумеруются с единицы).

* Output format
Для каждого запроса выведите НОД всех чисел соответствующего участка массива. Разделяйте числа переводами строк.

**TASK 5**

Написать программу, вычисляющую префикс-функцию от заданной строки

**TASK 6**

  Реализуйте структуру данных для хранения элементов и увеличения нескольких подряд идущих элементов на одно и то же число.

* Input format
В первой строке вводится одно натуральное число N(1 ≤ N ≤ 105) - количество чисел в массиве.

Во второй строке вводятся N чисел от 1 до 100000 - элементы массива.

В третьей строке вводится одно натуральное число M(1 ≤ M ≤ 500000) - количество запросов.

Каждая из следующих M строк представляет собой описание запроса. Сначала вводится одна буква, кодирующая вид запроса (g - получить текущее значение элемента по номеру, a - увеличить все элементы на отрезке). Следом за g вводится одно число - номер элемента. Следом за a вводится три числа - левый и правый концы отрезка и число add, на которое нужно увеличить все элементы данного отрезка массва(1 ≤ add ≤ 100000).

* Output format
Выведите ответы на запросы вида g, разделяя их переводами строк.

**TASK 7**

У Сережи есть скобочная последовательность s1, s2, ..., sn, или, другими словами, строка s длины n, состоящая из символов ( и ).

Сереже нужно ответить на m запросов, каждый из которых характеризуется двумя целыми числами li, ri (1 ≤ li ≤ ri ≤ n). Ответом на i-ый запрос является длина наибольшей правильной скобочной подпоследовательности последовательности sli, sli + 1, ..., sri. Помогите Сереже ответить на все запросы.

* Input format
Первая строка содержит последовательность символов без пробелов s1, s2, ..., sn (1 ≤ n ≤ 106). Каждый символ это либо (, либо ). Вторая строка содержит целое число m (1 ≤ m ≤ 105) количество запросов. Каждая из следующих m строк содержит пару целых чисел. В i-ой строке записаны числа li, ri (1 ≤ li ≤ ri ≤ n) - описание i-го запроса.

* Output format
Выведите ответ на каждый запрос в отдельной строке. Ответы выводите в порядке следования запросов во входных данных.

**TASK 8**
Вам задан массив Z-функции некоторой строки. Ваша задача - найти лексикографически минимальную строку, массив Z-функции которой совпадет с данным. Алфавит для построения ответа: a-z.

* Input format
На входе в первой строке дано число N - размер массива префикс-функции (0 ≤ N ≤ 10^6). На второй строке через пробел идут сами элементы. Гарантируется, что исходный массив является корректным массивом Z-функции.

**TASK 9**

Вам задан массив префикс-функции некоторой строки. Ваша задача - найти лексикографически минимальную строку, массив префикс-функции которой совпадет с данным. Алфавит для построения ответа: a-z.

* Input format
На входе в первой строке дано число N - размер массива префикс-функции (0 ≤ N ≤ 10^6). На второй строке через пробел идут сами элементы. Гарантируется, что исходный массив является корректным массивом префикс-функции.

* Output format
Выведите искомую строку.

**TASK 10**

Найти все вхождения строки T в строку S.

* Input format
Первые две строки входных данных содержат строки S и T, соответственно. Длины строк больше 0 и меньше 50000, строки содержат только латинские буквы.

* Output format
Выведите номера символов, начиная с которых строка T входит в строку S, в порядке возрастания.

**TASK 11**

Реализуйте структуру данных для эффективного вычисления значения максимального из нескольких подряд идущих элементов массива, а также количества элементов, равных максимальному на данном отрезке.

* Input format
В первой строке вводится одно натуральное число N(1 ≤ N ≤ 105) - количество чисел в массиве.

Во второй строке вводятся N чисел от 1 до 100000 - элементы массива.

В третьей строке вводится одно натуральное число K(1 ≤ K ≤ 30000) — количество запросов на вычисление максимума.

В следующих K строках вводится по два числа - номера левого и правого элементов отрезка массива (считается, что элементы массива нумеруются с единицы).

* Output format
Для каждого запроса выведите в отдельной строке через пробел значение максимального элемента на указанном отрезке массива и количество максимальных элементов на этом отрезке.

**TASK 12**

Задан ориентированный граф, каждое ребро которого обладает целочисленной пропускной способностью. Найдите максимальный поток из вершины с номером 1 в вершину с номером n.

В этой задаче необходимо реализовать алгоритм Форда-Фалкерсона.

* Input format
Первая строка входного файла содержит n и m - количество вершин и количество ребер графа (2 ≤ n ≤ 100, 1 ≤ m ≤ 1000). Следующие m строк содержат по три числа: номера вершин, которые соединяет соответствующее ребро графа и его пропускную способность. Пропускные способности не превосходят 105.

* Output format
В выходной файл выведите одно число - величину максимального потока из вершины с номером 1 в вершину с номером n.

